#ifndef TMATS_DATA_H_
#define TMATS_DATA_H_

#include <map>
#include <vector>
#include <set>
#include <string>
#include "spdlog/spdlog.h"
#include "iterable_tools.h"
#include "tmats_parser.h"
#include "parse_text.h"
#include "ch10_pcm_tmats_data.h"
#include "ch10_packet_type.h"

#define RETFAIL(x, y) if(!(x)) {SPDLOG_WARN("TMATSData::Parse: Failed to MapAttrs: " y); return false; }
#define POPFAIL(x, y, z) if(!(x)) {SPDLOG_ERROR("PopulatePCMDataObject: Failed to set value \"{:s}\" for code \"{:s}\"", y, z); return false; }

using cmap = std::map<std::string, std::string>;
using cmapvec = std::map<std::string, std::vector<std::string>>;
using cmapmap = std::map<std::string, std::map<std::string, std::string>>;
using pcmdata_map = std::map<int, Ch10PCMTMATSData>;


class TMATSData
{
private:
	cmap chanid_to_source_map_;
    cmap chanid_to_type_map_;
	cmap chanid_to_429_format_;
    cmapvec	chanid_to_429_subchans_;
	cmapmap chanid_to_429_subchan_and_name_;
    unilateral_map pcm_index_to_code_and_values_;
    pcmdata_map tmats_pcm_data_map_;
    ParseText pt_;


public:
	const cmap& chanid_to_source_map;
    const cmap& chanid_to_type_map;
	const cmap& chanid_to_429_format;
	const cmapvec& chanid_to_429_subchans;
	const cmapmap& chanid_to_429_subchan_and_name;
    // const unilateral_map& pcm_index_to_code_and_values;
    const pcmdata_map tmats_pcm_data_map;

    static const std::map<Ch10PacketType, std::string> TMATS_channel_data_type_map_;
    TMATSData();
    virtual ~TMATSData() {}

    virtual const cmap& GetChannelIDToTypeMap() const { return chanid_to_type_map_; } 
    virtual const cmap& GetChannelIDToSourceMap() const { return chanid_to_source_map_; }
    virtual const cmap& GetChannelIDTo429Format() const { return chanid_to_429_format_; }
    virtual const cmapvec& GetChannelIDTo429Subchans() const { return chanid_to_429_subchans_; }
    virtual const cmapmap& GetChannelIDTo429SubchanAndName() const { return chanid_to_429_subchan_and_name_; }


    /*
    Parse TMATS matter passed in the form of a string. 

    Args:
        tmats_data      --> String representation of entire
                            TMATs blob. Includes formatting
                            chars such as newlines.
    	parsed_pkt_types--> Set of Ch10PacketType that contains only the
							present and parsed types

    Return:
        False if one of the attributes fails to map; true
        otherwise.
    */
   bool Parse(const std::string& tmats_data, const std::set<Ch10PacketType>& parsed_pkt_types);


    //////////////////////////////////////////////////////////////////////////
    //                  internal functions
    //////////////////////////////////////////////////////////////////////////

    /*
    Combine two cmapmaps under the assumption that the key of the submaps
    ought to be matched.
    */
    void CombineMaps(const cmapmap& map1, const cmapmap& map2, cmapmap& outmap) const;



    /*
    Filter channel ID to type map by the Ch10PacketType.

    Ex channel ID to type map:
    23: 1553IN
    24: 429IN
    27: 1553IN

    FilterTMATSType(map, Ch10PacketType::MILSTD1553_F1) yields:
    23: 1553IN
    27: 1553IN
    
    Args:
        type_map    --> Channel ID to type map 
                        (parser.MapAttrs("R-x\\TK1-n", "R-x\\CDT-n", chanid_to_type_map_))
        type_enum   --> Ch10PacketType
        filtered_map--> Filtered type map including only entries relevant to type_enum


    Return:
        True if no errors occur; false otherwise 
    */
    virtual bool FilterTMATSType(const cmap& type_map, Ch10PacketType type_enum,
        cmap& filtered_map) const;



    /*
    Filter an input map in which the key is the channel ID by the channel 
    ID to type map. To be used with a filtered map generated by 
    FilterTMATSType.

    Ex input map:
    24: SOME_VALUE

    Ex channel ID to type map:
    23: 1553IN
    24: 429IN
    27: 1553IN

    FilterByChannelIDToType(type_map, input_map) yields:
    24: SOME_VALUE
    
    Args:
        type_map    --> Channel ID to type map 
                        (parser.MapAttrs("R-x\\TK1-n", "R-x\\CDT-n", chanid_to_type_map_))
        input_map   --> Input map in which the key is a channel ID.

    Return:
        Filtered input_map
    */
    virtual cmap FilterByChannelIDToType(const cmap& type_map, const cmap& input_map) const;


    /*
    Assign and cast values from a map of tmats codes to string values to 
    a Ch10PCMTMATSData object.

    Args:
        code_to_vals    --> string:string map of codes to values
        pcm_data        --> Reference to CH10PCMTMATSData object

    Return:
        False if a value can't be casted to the correct type, 
        otherwise true.

    */
    bool PopulatePCMDataObject(const cmap& code_to_vals, 
        Ch10PCMTMATSData& pcm_data);


    /*
    Helper functions for PopulatePCMDataObject. Cast and set the 
    value of relevant Ch10PCMTMATSData member.

    Args:
        val     --> String value to be casted and assigned to a 
                    member of Ch10PCMTMATSData object.
        dest_prt--> Pointer to value which will be assigned.

    Return:
        False if the string value can't be casted to the appropriate
        type or if the tmats code doesn't match the associated 
        CH10PCMTMATSData::code_to_*_vals_map_, otherwise true.
    */
    template<typename T>
    bool SetPCMDataValue(const std::string& val, T* dest_ptr);


    /*
    Sub routine for ::Parse which handles only PCM data parsing from
    raw TMATs bytes to a pcmdata_map. 

    Args:
        parser  --> TMATsParser instantiated with TMATs matter
        pcmdata --> pcmdata_map type to populate with parsed
                    PCM data

    Return:
        False if an error occurs which should halt parsing altogether.
    */
    bool ParsePCMAttributes(TMATSParser& parser, pcmdata_map& pcmdata);

};

template<typename T>
bool TMATSData::SetPCMDataValue(const std::string& val, T* dest_ptr)
{
    SPDLOG_ERROR("SetPCMDataValue: dest_ptr type "
    "does not have a specialized template function.");
    return false;
}

template<>
inline bool TMATSData::SetPCMDataValue<std::string>(const std::string& val, std::string* dest_ptr)
{
    *dest_ptr = val;
    return true;
}

template<>
inline bool TMATSData::SetPCMDataValue<float>(const std::string& val, float* dest_ptr)
{
    double temp_val = 0.0;
    if(!pt_.ConvertDouble(val, temp_val))
    {
        SPDLOG_ERROR("SetPCMDataValue: Failed to "
        "convert value {:s} to float", val);
        return false;
    }
    *dest_ptr = static_cast<float>(temp_val);
    return true;
}

template<>
inline bool TMATSData::SetPCMDataValue<int>(const std::string& val, int* dest_ptr)
{
    int temp_val = 0;
    if(!pt_.ConvertInt(val, temp_val))
    {
        SPDLOG_ERROR("SetPCMDataValue: Failed to "
        "convert value {:s} to int", val);
        return false;
    }
    *dest_ptr = temp_val;
    return true;
}

#endif  // TMATS_DATA_H_
